//! Tool for parsing binary blobs generated by [`minicov`] and generating GCOV
//! .gcda files.
//!
//! [`minicov`]: https://docs.rs/minicov

#![feature(profiler_runtime_lib)]
#![warn(missing_docs)]
#![warn(rust_2018_idioms)]

use serde::Deserialize;
use std::ffi::CString;
use std::fs;
use std::os::raw::c_char;
use std::path::PathBuf;
use structopt::StructOpt;

// We need to pull in the profiling runtime for the `llvm_gcda_*` functions.
#[allow(unused_extern_crates)]
extern crate profiler_builtins;
extern "C" {
    fn llvm_gcda_start_file(
        orig_filename: *const c_char,
        version: *const [c_char; 4],
        checksum: u32,
    );
    fn llvm_gcda_emit_function(
        ident: u32,
        function_name: *const c_char,
        func_checksum: u32,
        use_extra_checksum: u8,
        cfg_checksum: u32,
    );
    fn llvm_gcda_emit_arcs(num_counters: u32, counters: *mut u64);
    fn llvm_gcda_summary_info();
    fn llvm_gcda_end_file();
}

/// Magic bytes at the start of the data to avoid deserializing garbage.
const MAGIC: [u8; 8] = *b"minicov\0";

/// File format version.
const VERSION: [u8; 4] = *b"v01\0";

/// Recording of a call to a `llvm_gcda_*` function.
///
/// We basically just capture the parameters to the functions and serialize them.
#[derive(Deserialize)]
enum CovEvent {
    StartFile {
        orig_filename: CString,
        version: [c_char; 4],
        checksum: u32,
    },
    EmitFunction {
        ident: u32,
        function_name: CString,
        func_checksum: u32,
        use_extra_checksum: u8,
        cfg_checksum: u32,
    },
    EmitArcs {
        counters: Vec<u64>,
    },
    SummaryInfo,
    EndFile,
    End,
}

#[derive(StructOpt)]
/// Tool to extract code coverage generated by minicov.
#[structopt(name = "cargo-minicov", bin_name = "cargo")]
enum Opt {
    /// Tool to extract code coverage generated by minicov.
    Minicov {
        /// List of input files to extract code coverage from.
        #[structopt(required = true, parse(from_os_str))]
        inputs: Vec<PathBuf>,
    },
}

fn main() -> Result<(), ()> {
    let Opt::Minicov { inputs } = Opt::from_args();

    for path in inputs {
        let bytes = fs::read(&path).map_err(|e| {
            eprintln!(
                "Could not open input file {}: {}",
                path.to_string_lossy(),
                e
            )
        })?;

        if !bytes.starts_with(&MAGIC) {
            eprintln!(
                "Input file {} does not contain minicov data",
                path.to_string_lossy()
            );
            return Err(());
        }
        let bytes = &bytes[MAGIC.len()..];
        if !bytes.starts_with(&VERSION) {
            eprintln!(
                "Input file {} is from an incompatible version of minicov",
                path.to_string_lossy()
            );
            return Err(());
        }
        let mut bytes = &bytes[VERSION.len()..];

        loop {
            let (event, rest) = postcard::take_from_bytes(bytes).map_err(|e| {
                eprintln!(
                    "Error deserializing coverage data {}: {}",
                    path.to_string_lossy(),
                    e
                )
            })?;
            bytes = rest;

            match event {
                CovEvent::StartFile {
                    orig_filename,
                    version,
                    checksum,
                } => unsafe { llvm_gcda_start_file(orig_filename.as_ptr(), &version, checksum) },
                CovEvent::EmitFunction {
                    ident,
                    function_name,
                    func_checksum,
                    use_extra_checksum,
                    cfg_checksum,
                } => unsafe {
                    llvm_gcda_emit_function(
                        ident,
                        function_name.as_ptr(),
                        func_checksum,
                        use_extra_checksum,
                        cfg_checksum,
                    )
                },
                CovEvent::EmitArcs { mut counters } => unsafe {
                    llvm_gcda_emit_arcs(counters.len() as u32, counters.as_mut_ptr())
                },
                CovEvent::SummaryInfo => unsafe { llvm_gcda_summary_info() },
                CovEvent::EndFile => unsafe { llvm_gcda_end_file() },
                CovEvent::End => break,
            }
        }
    }

    Ok(())
}
