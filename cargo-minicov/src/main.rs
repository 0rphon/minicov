//! Tool for parsing binary blobs generated by [`minicov`] and generating GCOV
//! .gcda files.
//!
//! [`minicov`]: https://docs.rs/minicov

#![feature(profiler_runtime_lib)]
#![warn(missing_docs)]
#![warn(rust_2018_idioms)]

use serde::Deserialize;
use std::ffi::CString;
use std::fs;
use std::os::raw::c_char;
use std::path::PathBuf;
use structopt::StructOpt;

// We need to pull in the profiling runtime for the `llvm_gcda_*` functions.
#[allow(unused_extern_crates)]
extern crate profiler_builtins;
extern "C" {
    fn llvm_gcda_start_file(
        orig_filename: *const c_char,
        version: u32,
        checksum: u32,
    );
    fn llvm_gcda_emit_function(
        ident: u32,
        func_checksum: u32,
        cfg_checksum: u32,
    );
    fn llvm_gcda_emit_arcs(num_counters: u32, counters: *mut u64);
    fn llvm_gcda_summary_info();
    fn llvm_gcda_end_file();
}

/// Magic bytes at the start of the data to avoid deserializing garbage.
const MAGIC: [u8; 8] = *b"minicov\0";

/// File format version.
const VERSION: [u8; 4] = *b"v02\0";

/// Recording of a call to a `llvm_gcda_*` function.
///
/// We basically just capture the parameters to the functions and serialize them.
#[derive(Deserialize)]
enum CovEvent {
    StartFile {
        orig_filename: CString,
        version: u32,
        checksum: u32,
    },
    EmitFunction {
        ident: u32,
        func_checksum: u32,
        cfg_checksum: u32,
    },
    EmitArcs {
        counters: Vec<u64>,
    },
    SummaryInfo,
    EndFile,
    End,
}

#[derive(StructOpt)]
/// Tool to extract code coverage generated by minicov.
#[structopt(name = "cargo-minicov", bin_name = "cargo")]
enum Opt {
    /// Tool to extract code coverage generated by minicov.
    Minicov {
        /// List of input files to extract code coverage from.
        #[structopt(required = true, parse(from_os_str))]
        inputs: Vec<PathBuf>,
    },
}

fn main() -> Result<(), ()> {
    let Opt::Minicov { inputs } = Opt::from_args();

    for path in inputs {
        let path_str = path.to_string_lossy();
        println!("Processing input file {}...", path_str);

        let bytes = fs::read(&path)
            .map_err(|e| eprintln!("Could not open input file {}: {}", path_str, e))?;

        // Outer loop to handle concatenated files
        let mut index = 0;
        let mut bytes = &bytes[..];
        'outer: loop {
            if index != 0 {
                println!("Processing appended data #{}...", index);
            }

            if !bytes.starts_with(&MAGIC) {
                eprintln!("Input file {} does not contain minicov data", path_str);
                return Err(());
            }
            bytes = &bytes[MAGIC.len()..];
            if !bytes.starts_with(&VERSION) {
                eprintln!(
                    "Input file {} is from an incompatible version of minicov",
                    path_str
                );
                return Err(());
            }
            bytes = &bytes[VERSION.len()..];

            loop {
                let (event, rest) = postcard::take_from_bytes(bytes).map_err(|e| {
                    eprintln!(
                        "Error deserializing coverage data {}: {}",
                        path.to_string_lossy(),
                        e
                    )
                })?;
                bytes = rest;

                match event {
                    CovEvent::StartFile {
                        orig_filename,
                        version,
                        checksum,
                    } => unsafe {
                        llvm_gcda_start_file(orig_filename.as_ptr(), version, checksum)
                    },
                    CovEvent::EmitFunction {
                        ident,
                        func_checksum,
                        cfg_checksum,
                    } => unsafe {
                        llvm_gcda_emit_function(
                            ident,
                            func_checksum,
                            cfg_checksum,
                        )
                    },
                    CovEvent::EmitArcs { mut counters } => unsafe {
                        llvm_gcda_emit_arcs(counters.len() as u32, counters.as_mut_ptr())
                    },
                    CovEvent::SummaryInfo => unsafe { llvm_gcda_summary_info() },
                    CovEvent::EndFile => unsafe { llvm_gcda_end_file() },
                    CovEvent::End => {
                        // Check for another set of input data appended to the
                        // end of the this one.
                        if !bytes.is_empty() {
                            index += 1;
                            continue 'outer;
                        } else {
                            break 'outer;
                        }
                    }
                }
            }
        }
    }

    println!("Done");
    Ok(())
}
